// GENERATED by ChatGPT
#include <string>
#include "cgn_api.h"

#if defined(_WIN32) // Windows implementation
#include <windows.h>
#include <tlhelp32.h>

namespace cgnv1 {
std::string Tools::get_parent_process_name() {
    std::string processName = "Unknown";
    DWORD currentPID = GetCurrentProcessId();
    DWORD parentPID = 0;

    // Take a snapshot of all processes
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return processName;
    }

    PROCESSENTRY32 pe32 = { sizeof(PROCESSENTRY32) };
    if (Process32First(hSnapshot, &pe32)) {
        do {
            if (pe32.th32ProcessID == currentPID) {
                parentPID = pe32.th32ParentProcessID;
                break;
            }
        } while (Process32Next(hSnapshot, &pe32));
    }
    CloseHandle(hSnapshot);

    // Get the parent process name
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return processName;
    }
    if (Process32First(hSnapshot, &pe32)) {
        do {
            if (pe32.th32ProcessID == parentPID) {
                processName = pe32.szExeFile;
                break;
            }
        } while (Process32Next(hSnapshot, &pe32));
    }
    CloseHandle(hSnapshot);

    return processName;
}
} //namespace

#elif defined(__APPLE__) || defined(__MACH__) // macOS implementation
#include <libproc.h>
#include <unistd.h>

namespace cgnv1 {
std::string Tools::get_parent_process_name() {
    std::string processName = "Unknown";
    pid_t parentPID = getppid();
    char pathBuffer[PROC_PIDPATHINFO_MAXSIZE];

    if (proc_pidpath(parentPID, pathBuffer, sizeof(pathBuffer)) > 0) {
        processName = std::string(pathBuffer);
    }

    return processName;
}
} //namespace

#elif defined(__linux__) // Linux implementation
#include <fstream>
#include <string>

namespace cgnv1 {
std::string Tools::get_parent_process_name() {
    std::string processName = "Unknown";
    std::ifstream statFile("/proc/self/stat");
    if (!statFile.is_open()) {
        return processName;
    }

    std::string content;
    std::getline(statFile, content);
    statFile.close();

    // Parent PID is the fourth field in the file
    size_t start = content.find_last_of(')') + 2;
    size_t field = 0;
    std::string parentPid;
    for (size_t i = start; i < content.size(); ++i) {
        if (content[i] == ' ') {
            ++field;
            if (field == 3) {
                break;
            }
        } else if (field == 2) {
            parentPid += content[i];
        }
    }

    // Get the parent process name from /proc/<PPID>/comm
    std::ifstream commFile("/proc/" + parentPid + "/comm");
    if (commFile.is_open()) {
        std::getline(commFile, processName);
        commFile.close();
    }

    return processName;
}
} //namespace

#else // Unsupported platform

namespace cgnv1 {
std::string Tools::get_parent_process_name() {
    return "Unsupported Platform";
}
} //namespace
#endif
